#load text file into R called 'data' 
data <- read.delim('purchase.txt', header= FALSE, sep = '\t', dec = '.')
head(data)
summary(data)
# add header and interpret the last colum as a date, extract year of purchase

colnames(data) <- c('customer_id', 'purchase_amount', 'data_of_purchase')
data$data_of_purchase = as.Date(data$data_of_purchase, "%Y-%m-%d")
data$year_of_purchase = as.numeric(format(data$data_of_purchase, "%Y"))

 #add headers and interpret the last column as a dae, extract year of purchase
colnames(data) <- c('customer_id', 'purchase_amount', 'data_of_purchase')
data$data_of_purchase = as.Date(data$data_of_purchase, "%Y-%m-%d")
data$days_since = as.numeric(difftime(time1 =  "2016-01-01",
                                      time2 = data$data_of_purchase,
                                      units = "days"))
#display the data after transformation
head(data)
summary(data)
#compute key marketing indicators using SQL language
library(sqldf)
# compute recency, frequency, and average purchase amount
customers <- sqldf("SELECT customer_id,
                   MIN(days_since) AS 'recency',
                   COUNT(*) AS 'frequency',
                   AVG(purchase_amount) AS 'amount'
                   FROM 
                   data
                   GROUP BY 1")
customers

#explore data
head(customers)
summary(customers)
hist(customers$recency)
hist(customers$frequency)
hist(customers$amount)
hist(customers$amount, breaks = 1000)
#preparing and transforming data 

#copy customer data into new data frame
new_data = customers

#remove customer id as a variable, store it as row names
head(new_data)
row.names(new_data) =new_data$customer_id
new_data$customer_id = NULL
head(new_data)

#take the log-transform of the amount, and plot
new_data$amount =log(new_data$amount)
hist(new_data$amount)
#standardize variables because all variable are different measurement 
#need to standardize standard from 0 using scale 
new_data =scale(new_data)
head(new_data)

#running a hierarchical segmentation ----

#compute distance metrics on standaized data
#this will likely generate an error on most machines
#d= dist(new_data)

#take a 10% sample- because if run dist then it will take too mcuh
#instead of that, compute seq with sample 1 to 18417 every other 10 and copute

sample = seq(1,18417, by= 10)
head(sample)
customers_sample =customers[sample,]
# upper code means use customers in sample and take every data
new_data_sample = new_data[sample,]

#compute distance metrics on standardized data
d= dist(new_data_sample)

#perform hierarchical clustering on distance metrics
c= hclust(d, method = 'ward.D2')

#plot de dendogram
plot(c)

#cut at 9 segments 
members = cutree(c,k =9)

#show 30 first customers, frequency table 
members[1:30]
table(members)

#show profile of each segment 
aggregate(customers_sample[ , 2: 4], by =list(members), mean)

#practice with frequency

new_data$frequency =log(new_data$frequency)
hist(new_data$frequency)
head(new_data)
new_data =scale(new_data)
head(new_data)
sample = seq(1,18417, by= 10)

head(sample)
customers_sample =customers[sample,]
d= dist(new_data_sample)
c= hclust(d, method = 'ward.D2')
plot(c)
members = cutree(c,k =5)
members[1:30]
table(members)
aggregate(customers_sample[ , 2: 4], by =list(members), mean)



#computing recency, frequnecy, monetary value ---- 
data <- read.delim('purchase.txt', header= FALSE, sep = '\t', dec = '.')

colnames(data) <- c('customer_id', 'purchase_amount', 'data_of_purchase')
data$data_of_purchase = as.Date(data$data_of_purchase, "%Y-%m-%d")
data$year_of_purchase = as.numeric(format(data$data_of_purchase, "%Y"))
data$days_since = as.numeric(difftime(time1 =  "2016-01-01",
                                      time2 = data$data_of_purchase,
                                      units = "days"))
head(data)
summary(data)

#compute key marketing indicatier using SQL language in 2015
library(sqldf)
customers_2015 = sqldf("SELECT customer_id,
                       MIN(days_since) AS 'recency',
                      MAX(days_since) AS 'first_purchase',
                       COUNT(*) AS 'frequency',
                       AVG(purchase_amount) AS 'amount'
                       FROM data 
                       GROUP BY 1")
head(customers_2015)
summary(customers_2015)
#explore data 
hist(customers_2015$recency)
hist(customers_2015$frequency)
hist(customers_2015$amount)
hist(customers_2015$amount, breaks = 100)

#how to create managerial segmentation ----

#complete segment solution using which, and exploiting previous test as input
customers_2015$segment ='NA'
customers_2015$segment[which(customers_2015$recency > 365*3)] = 'inactive'

customers_2015$segment[which(customers_2015$recency <= 365*3&
                               customers_2015$recency > 365*2)] = 'cold'

customers_2015$segment[which(customers_2015$recency <= 365*2 &
                               customers_2015$recency > 365*1 )] = 'warm'

customers_2015$segment[which(customers_2015$recency <= 365*1 )] = 'active'

customers_2015$segment[which(customers_2015$segment == 'warm' & customers_2015$first_purchase <= 365*2 )] = 'new warm'

customers_2015$segment[which(customers_2015$segment == 'warm' & customers_2015$amount < 100 )] = 'warm low value'

customers_2015$segment[which(customers_2015$segment == 'warm' & customers_2015$amount >= 100 )] = 'warm high value'

customers_2015$segment[which(customers_2015$segment == 'active' & customers_2015$first_purchase <= 365 )] = 'new active'
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$first_purchase <= 365)] = "new active"
customers_2015$segment[which(customers_2015$segment == "active" &  customers_2015$amount >= 100)] = "active high value"
customers_2015$segment[which(customers_2015$segment == "active" & customers_2015$amount < 100)] = "active low value"
--------------------new added values for assignment two separate group in 'new active'-----
customers_2015$segment[which(customers_2015$segment == "new active" & customers_2015$amount >= 100)] = "new active high"
customers_2015$segment[which(customers_2015$segment == "new active" & customers_2015$amount < 100)] = "new active low"
table(customers_2015$segment)

aggregate(x= customers_2015[,2:5], by = list(customers_2015$segment), mean)

#re-order factor in a way that makes sense 
customers_2015$segment =factor(x= customers_2015$segment, levels = c('inactive','cold',
                                                                     'warm high value', 'warm low value',
                                                                     'new warm', 'active high value',
                                                                     'active low value','new active',
                                                                     'new active high', 'new active low'))
table(customers_2015$segment)
aggregate(x= customers_2015[,2:5], by = list(customers_2015$segment), mean)
 
#segmenting a database retrospectively ----


#compute recency, frequencey, and average purchase amount in 2014
customers_2014 =sqldf("SELECT customer_id,
                      MIN(days_since) -365 AS 'recency',
                      MAX(days_since) -365 AS 'first_purchase',
                      count(*) AS 'frequnecy',
                      AVG(purchase_amount) AS 'amount'
                      FROM data
                      Where days_since >365
                      GROUP BY 1" )

customers_2014$segment ='NA'
customers_2014$segment[which(customers_2014$recency > 365*3)] = 'inactive'
customers_2014$segment[which(customers_2014$recency <= 365*3& customers_2014$recency > 365*2)] = 'cold'
customers_2014$segment[which(customers_2014$recency <= 365*2 & customers_2014$recency > 365*1 )] = 'warm'

customers_2014$segment[which(customers_2014$recency <= 365*1 )] = 'active'

customers_2014$segment[which(customers_2014$segment == 'warm' &  customers_2014$first_purchase <= 365*2 )] = 'new warm'

customers_2014$segment[which(customers_2014$segment == 'warm' & customers_2014$amount < 100 )] = 'warm low value'

customers_2014$segment[which(customers_2014$segment == 'warm' & customers_2014$amount >= 100 )] = 'warm high value'

customers_2014$segment[which(customers_2014$segment == 'active' & customers_2014$first_purchase <= 365 )] = 'new active'

customers_2014$segment[which(customers_2014$segment == 'active' &  customers_2014$amount < 100 )] = 'active low value'
customers_2014$segment[which(customers_2014$segment == 'active' & customers_2014$amount > 100 )] = 'active high value'

customers_2014$segment =factor(x= customers_2014$segment, levels = c('inactive','cold',
                                                                     'warm high value', 'warm low value',
                                                                     'new warm', 'active high value',
                                                                     'active low value','new active' ))
table(customers_2014$segment)
pie(table(customers_2014$segment),col = rainbow(24))
aggregate(x= customers_2014[,2:5], by = list(customers_2014$segment), mean)

#computing revenue generation per segment ----
revenue_2015 = sqldf("SELECT customer_id,
                     SUM (purchase_amount) AS 'revenue_2015'
                     FROM data
                     WHERE year_of_purchase = 2015
                     GROUP BY 1")
summary(revenue_2015)
#merge 2015 customers and 2015 revenue
actual =merge(customers_2015,revenue_2015, all.x = TRUE)
View(actual)
actual$revenue_2015[is.na(actual$revenue_2015)] = 0

#show average revenue per customer and per segement 
aggregate(x= actual$revenue_2015, by = list(customers_2015$segment), mean)

forward =merge(customers_2014, revenue_2015, all.x = TRUE)
forward$revenue_2015[is.na(forward$revenue_2015)] =0
View(forward)
r =aggregate(x= forward$revenue_2015, by = list(customers_2014$segment), mean)
print(r)

#re-order and display result 
r= r[order(r$x, decreasing = TRUE), ]
print(r)
barplot(r$x, names.arg = r$Group.1)
                                     
